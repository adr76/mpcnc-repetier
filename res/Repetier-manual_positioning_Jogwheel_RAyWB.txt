/* 
Hi all !
as i use repetier fw for milling , i found  that positioning for offsets via encoder is not very efficient.
As REPETIER added the analog keypad support i thought about positioning via jostick.
it needs three analog inputs and works via potentiometer-based joysticks.The encoder and other functions keep as before.

i use 1 Analog channel per axis and define several "buttons" depending on joystick position and UIActions define stepwidths.
feedrate for these steps is defined as"JOGRATE" and of coarse very slow.
I tested the code on DUE and it works fine. THE min/max numbers for the buttons depend on the hardware setup,
i used 4.7 KOhm pullups and jostick as variable resistor 0...10 Kohm similar to thermistor input.
thats what i modified in code (FW 92.8 ): 
*/

//############Changes in UICONFIG.H


void uiInitKeys() {
#if UI_HAS_KEYS!=0
UI_KEYS_INIT_CLICKENCODER_LOW(43,45); // click encoder on pins 43 and 45. Phase is connected with gnd for signals.
UI_KEYS_INIT_BUTTON_LOW(47); // push button, connects gnd to pin
#endif
}

void uiCheckKeys(uint16_t &action) {

#if UI_HAS_KEYS!=0

UI_KEYS_CLICKENCODER_LOW_REV(43,45); // click encoder on pins 43 and 45. Phase is connected with gnd for signals.
UI_KEYS_BUTTON_LOW(47,UI_ACTION_OK); // push button, connects gnd to pin
#endif

// Here starts Joystick assignment
// button assignment x-axis
struct {
uint16_t min;
uint16_t max;
uint16_t action;
} keys_x[] = {
{ 0, 800, UI_ACTION_X_DOWN10 }, // down 10 mm steps
{ 810, 1200, UI_ACTION_X_DOWN1 }, // down 1 mm steps
{ 1210, 1800, UI_ACTION_X_DOWN01 }, // down 0.1 mm steps
{ 1810, 2000, UI_ACTION_X_DOWN001 }, // down 0.01 mm steps

{ 2200, 2350, UI_ACTION_X_UP001 }, // up 0.01mm steps
{ 2370, 2500, UI_ACTION_X_UP01 }, // up 0.1 mm steps
{ 2510, 2650, UI_ACTION_X_UP1 }, // up 1mm steps
{ 2660, 3000, UI_ACTION_X_UP10 }, // up 10 mm steps
};
const uint8_t numOfKeys_x = sizeof(keys_x) / sizeof(keys_x[0]);

extern volatile uint16_t osAnalogInputValues[ANALOG_INPUTS];
uint16_t adc_x = osAnalogInputValues[KEYPAD_ANALOG_INDEX] >> (ANALOG_REDUCE_BITS);
if (adc_x < 4000) {
for (int8_t ix = 0; ix < numOfKeys_x; ++ix) {
if ((adc_x > keys_x[ix].min) && (adc_x< keys_x[ix].max)) {
action = keys_x[ix].action;
return;
}
}
}

//button assignment y-axis


struct {
uint16_t min;
uint16_t max;
uint16_t action;
}

keys_y[] = {

{ 0, 800, UI_ACTION_Y_UP10 }, // Up 10 mm Steps
{ 810, 1200, UI_ACTION_Y_UP1 }, // Up 1mm Steps
{ 1210,1800, UI_ACTION_Y_UP01 }, // Up 0.1 mm Steps
{ 1810,2000, UI_ACTION_Y_UP001 }, // Up 0.01 mm steps

{ 2200, 2350, UI_ACTION_Y_DOWN001 }, // Down 0.01mm Steps
{ 2370, 2500, UI_ACTION_Y_DOWN01 }, // Down 0.1mm Steps
{ 2510, 2650, UI_ACTION_Y_DOWN1 }, // Down 1mm Steps
{ 2660, 3000, UI_ACTION_Y_DOWN10 }, // Down 10 mm Steps
};


const uint8_t numOfKeys2 = sizeof(keys_y) / sizeof(keys_y[0]);

uint16_t adc_y = osAnalogInputValues[KEYPAD2_ANALOG_INDEX] >> (ANALOG_REDUCE_BITS);
if ( adc_y < 4000) {
for (int8_t iy = 0; iy < numOfKeys2; ++iy) {
if ((adc_y > keys_y[iy].min) && (adc_y < keys_y[iy].max)) {
action = keys_y[iy].action;
return;
}
}
}

// Button assignment Z-Axis
struct {
uint16_t min;
uint16_t max;
uint16_t action;
}

keys_z[] = {


{ 810, 1200, UI_ACTION_Z_UP1 }, // Up 1mm steps
{ 1210,1800, UI_ACTION_Z_UP01 }, // Up 0.1 mm steps
{ 1810,2000, UI_ACTION_Z_UP001 }, // Up 0.01 mm steps

{ 2200, 2350, UI_ACTION_Z_DOWN001 }, //Down 0.01 mm steps
{ 2370, 2500, UI_ACTION_Z_DOWN01 }, //Down 0.1 mm steps
{ 2510, 2650, UI_ACTION_Z_DOWN1 }, // Down 1mm steps

};


const uint8_t numOfKeysz = sizeof(keys_z) / sizeof(keys_z[0]);

uint16_t adc_z = osAnalogInputValues[KEYPAD3_ANALOG_INDEX] >> (ANALOG_REDUCE_BITS);
if ( adc_z < 4000) {
for (int8_t iz = 0; iz < numOfKeysz; ++iz) {
if ((adc_z > keys_z[iz].min) && (adc_z < keys_z[iz].max)) {
action = keys_z[iz].action;
return;
}
}
}


}


//############## Changes in UI.cpp

case UI_ACTION_X_UP:
case UI_ACTION_X_DOWN:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(((action == UI_ACTION_X_UP) ? 1.0 : -1.0) * (Printer::axisStepsPerMM[X_AXIS]), 0, 0, 0, Printer::homingFeedrate[X_AXIS], false,false);
break;

case UI_ACTION_X_UP001:
case UI_ACTION_X_DOWN001:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(((action == UI_ACTION_X_UP001) ? 1.0 : -1.0) * (Printer::axisStepsPerMM[X_AXIS]/100), 0, 0, 0, JOGRATE, false,false);
break;

case UI_ACTION_X_UP01:
case UI_ACTION_X_DOWN01:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(((action == UI_ACTION_X_UP01) ? 1.0 : -1.0) * (Printer::axisStepsPerMM[X_AXIS]/10), 0, 0, 0, JOGRATE, false,false);
break;


case UI_ACTION_X_UP1:
case UI_ACTION_X_DOWN1:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(((action == UI_ACTION_X_UP1) ? 1.0 : -1.0) * Printer::axisStepsPerMM[X_AXIS], 0, 0, 0, JOGRATE, false,false);
break;

case UI_ACTION_X_UP10:
case UI_ACTION_X_DOWN10:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(((action == UI_ACTION_X_UP10) ? 1.0 : -1.0) * (Printer::axisStepsPerMM[X_AXIS]*10), 0, 0, 0, JOGRATE, false,false);
break;


case UI_ACTION_Y_UP:
case UI_ACTION_Y_DOWN:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, ((action == UI_ACTION_Y_UP) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Y_AXIS]/100, 0, 0,Printer::homingFeedrate[Y_AXIS], false,false);
break;

case UI_ACTION_Y_UP001:
case UI_ACTION_Y_DOWN001:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, ((action == UI_ACTION_Y_UP001) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Y_AXIS]/100, 0, 0, JOGRATE, false,false);
break;
case UI_ACTION_Y_UP01:
case UI_ACTION_Y_DOWN01:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, ((action == UI_ACTION_Y_UP01) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Y_AXIS]/10, 0, 0, JOGRATE, false,false);
break;
case UI_ACTION_Y_UP1:
case UI_ACTION_Y_DOWN1:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, ((action == UI_ACTION_Y_UP1) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Y_AXIS], 0, 0, JOGRATE, false,false);
break;
case UI_ACTION_Y_UP10:
case UI_ACTION_Y_DOWN10:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, ((action == UI_ACTION_Y_UP10) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Y_AXIS]*10, 0, 0, JOGRATE, false,false);
break;






case UI_ACTION_Z_UP:
case UI_ACTION_Z_DOWN:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, 0, ((action == UI_ACTION_Z_UP) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Z_AXIS], 0, Printer::homingFeedrate[Z_AXIS], false,false);
break;

case UI_ACTION_Z_UP001:
case UI_ACTION_Z_DOWN001:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, 0, ((action == UI_ACTION_Z_UP001) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Z_AXIS]/100, 0, JOGRATE, false,false);
break;

case UI_ACTION_Z_UP01:
case UI_ACTION_Z_DOWN01:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, 0, ((action == UI_ACTION_Z_UP01) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Z_AXIS]/10, 0, JOGRATE, false,false);
break;

case UI_ACTION_Z_UP1:
case UI_ACTION_Z_DOWN1:
if(!allowMoves) return action;
PrintLine::moveRelativeDistanceInStepsReal(0, 0, ((action == UI_ACTION_Z_UP1) ? 1.0 : -1.0) * Printer::axisStepsPerMM[Z_AXIS], 0, JOGRATE, false,false);
break;



//########### Changes in ui. H ( additional uiactions)
#define UI_ACTION_X_UP1 114
#define UI_ACTION_X_DOWN1 115
#define UI_ACTION_X_UP01 116
#define UI_ACTION_X_DOWN01 117
#define UI_ACTION_X_UP001 118
#define UI_ACTION_X_DOWN001 119
#define UI_ACTION_X_UP10 120
#define UI_ACTION_X_DOWN10 121

#define UI_ACTION_Y_UP1 122
#define UI_ACTION_Y_DOWN1 123
#define UI_ACTION_Y_UP01 124
#define UI_ACTION_Y_DOWN01 125
#define UI_ACTION_Y_UP001 126
#define UI_ACTION_Y_DOWN001 127
#define UI_ACTION_Y_UP10 128
#define UI_ACTION_Y_DOWN10 129


#define UI_ACTION_Z_UP1 130
#define UI_ACTION_Z_DOWN1 131
#define UI_ACTION_Z_UP01 132
#define UI_ACTION_Z_DOWN01 133
#define UI_ACTION_Z_UP001 134
#define UI_ACTION_Z_DOWN001 135


//############Changes in Repetier.h
// add:


#if defined(ADC_KEYPAD2_PIN) && (ADC_KEYPAD2_PIN > -1)
#define KEYPAD2_ANALOG_INPUTS 1
#define KEYPAD2_ANALOG_INDEX EXT0_ANALOG_INPUTS+EXT1_ANALOG_INPUTS+EXT2_ANALOG_INPUTS+EXT3_ANALOG_INPUTS+EXT4_ANALOG_INPUTS+EXT5_ANALOG_INPUTS+BED_ANALOG_INPUTS+THERMO_ANALOG_INPUTS+KEYPAD_ANALOG_INPUTS
#define KEYPAD2_ANALOG_CHANNEL THERMO_COMMA ADC_KEYPAD2_PIN
#else
#define KEYPAD2_ANALOG_INPUTS 0
#define KEYPAD2_ANALOG_CHANNEL
#endif


#if defined(ADC_KEYPAD3_PIN) && (ADC_KEYPAD3_PIN > -1)
#define KEYPAD3_ANALOG_INPUTS 1
#define KEYPAD3_ANALOG_INDEX EXT0_ANALOG_INPUTS+EXT1_ANALOG_INPUTS+EXT2_ANALOG_INPUTS+EXT3_ANALOG_INPUTS+EXT4_ANALOG_INPUTS+EXT5_ANALOG_INPUTS+BED_ANALOG_INPUTS+THERMO_ANALOG_INPUTS+KEYPAD_ANALOG_INPUTS+KEYPAD2_ANALOG_INPUTS
#define KEYPAD3_ANALOG_CHANNEL THERMO_COMMA ADC_KEYPAD3_PIN
#else
#define KEYPAD3_ANALOG_INPUTS 0
#define KEYPAD3_ANALOG_CHANNEL
#endif

// change:
/** \brief number of analog input signals. Normally 1 for each temperature sensor */
#define ANALOG_INPUTS (EXT0_ANALOG_INPUTS+EXT1_ANALOG_INPUTS+EXT2_ANALOG_INPUTS+EXT3_ANALOG_INPUTS+EXT4_ANALOG_INPUTS+EXT5_ANALOG_INPUTS+BED_ANALOG_INPUTS+THERMO_ANALOG_INPUTS+KEYPAD_ANALOG_INPUTS+KEYPAD2_ANALOG_INPUTS+KEYPAD3_ANALOG_INPUTS)
#if ANALOG_INPUTS > 0
/** Channels are the MUX-part of ADMUX register */
#define ANALOG_INPUT_CHANNELS {EXT0_ANALOG_CHANNEL EXT1_ANALOG_CHANNEL EXT2_ANALOG_CHANNEL EXT3_ANALOG_CHANNEL EXT4_ANALOG_CHANNEL EXT5_ANALOG_CHANNEL BED_ANALOG_CHANNEL THERMO_ANALOG_CHANNEL KEYPAD_ANALOG_CHANNEL KEYPAD2_ANALOG_CHANNEL KEYPAD3_ANALOG_CHANNEL}
#endif


//#######Changes in configuration.h ( add keypad2 and3)

/* You can have one keypad connected via single analog pin as seen on
some printers with Melzi V2.0 board, 20x4 LCD and 5 buttons keypad. This must be
the analog pin number! */
#define ADC_KEYPAD_PIN ORIG_ADC_KEYPAD_PIN
#define ADC_KEYPAD2_PIN ORIG_ADC_KEYPAD2_PIN
#define ADC_KEYPAD3_PIN ORIG_ADC_KEYPAD3_PIN
#define JOGRATE 3 // fixed feedrate for slow moves during joystick moves
// define pins directly or via pins.h respectively userpins.h
// for a better overview i use reference names and define the pin numbers in userpins.h
